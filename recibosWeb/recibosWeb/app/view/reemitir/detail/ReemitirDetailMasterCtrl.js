Ext.define('recibosWeb.view.reemitir.detail.ReemitirDetailMasterCtrl', {
    extend: 'iDynamicsFront.util.ViewController',
    alias : 'controller.reemitir-detailmaster',
    control: {
        'reemitir_reemitirdetailform': {
//            beforesaveform: 'reemitirOnBeforeSave',
//            saveform      : 'reemitirSave'
        },
        'reemitir_reemitirdetailgrid' : {
            selectionchange: 'onSelectionChange'
        }

    },
    reemitirViewDetailGrid: function (modelSelected) {
        var me = this, grid;
        grid = me.getView().down('reemitir_reemitirdetailgrid');
        grid.reconfigure(modelSelected.emisiones());
    },

    /**
     * @autogenerated
     * Function that load the selected record's detail
     *
     * @param {Ext.selection.RowModel}
     *            modelSelected
     * @param {recibosWeb.view.direccion.Detail}
     *            detail
     */
    reemitirViewDetail: function (modelSelected) {
        var me = this, uxfieldArray, uxfieldNArray,
            uxfield, uxfieldN, boundList, len, len2, model, datos, detail, enabled, bt;

        detail = me.getView().down('reemitir_reemitirdetailform');
        recibosWeb.model.CabeceraDTO.load(modelSelected.get('id'), {
            callback: function (reemitir, operation) {
                if (reemitir.data === null) {
                    me.error(operation.getError());
                } else {
                    model = reemitir;
                    detail.getForm().loadRecord(model);
                    /*
                    // Busca el botón con reference: 'enableBtn'
                    bt = me.lookupReference('enableBtn');
                    //añadimos o eliminamos la clase disabled en función del atributo enabled
                    enabled = model.get('enabled');
                    detail[(enabled ? 'remove' : 'add') + 'Cls']('disabled');
                    bt.setText(enabled ? 'Desactivar' : 'Activar');
                    enabled ? bt.setGlyph(Glyphs.getIcon('lock')) : bt.setGlyph(Glyphs.getIcon('unlock'));
                    */
                    //me.getView().setTitle(['Detalle', usuario.get('name'), usuario.get('surname')].join(' '));
//                    me.getView().setTitle(t('reemitir.detail.title')+ ' ('+);

                    // seek simple search components and
                    // assign them to the initial value
                    uxfieldArray = Ext.ComponentQuery.query('uxdialogfield', detail);
                    len = uxfieldArray.length;
                    while (len--) {
                        uxfield = uxfieldArray[len];

                        uxfield.value = model.get(uxfield.name);
                        uxfield.setRawValue(model
                            .get(uxfield.displayFieldIni));

                    }

                    // seek multiple search components
                    // and assign them to the initial value
                    uxfieldNArray = Ext.ComponentQuery.query('uxdialogfieldn', detail);
                    len = uxfieldNArray.length;
                    while (len--) {
                        uxfieldN = uxfieldNArray[len];
                        boundList = uxfieldN.down('boundlist');

                        len2 = model.get(uxfieldN.name).length;
                        if (len2 > 0) {
                            datos = [];
                            while (len2--) {
                                datos[len2] = {};
                                datos[len2][uxfieldN.valueField] = model
                                    .get(uxfieldN.name)[len2][uxfieldN.valueField];
                                datos[len2][uxfieldN.displayField] = model
                                    .get(uxfieldN.name)[len2][uxfieldN.displayField];
                            }
                            boundList.getStore().loadData(datos);
                        }
                    }
                    me.reemitirViewDetailGrid(model);
                }
            }
        });
    },

    /**
     * @autogenerated
     * Reload all the stores needed
     *
     * @return {[Promises]}
     *
     * FMM
     * En este caso no es necesario porque el detalle no debe cargar nada y por lo tanto no tiene stores
     */
    reemitirReloadDependentStores: function (detail) {
        var me = this, viewModel = this.getViewModel(),
            stores = ['reemitirs'], storeLoader;

        storeLoader = function (store) {
            new RSVP.Promise(function (resolve, reject) {
                resolve();
                /*
                 viewModel.getStore(store).load({
                 callback: function (roles, operation, success) {
                 if (!success) {
                 if (operation.getError().code === null) {
                 me.error(operation.getError());
                 }
                 reject();
                 } else {
                 resolve(roles);
                 }
                 }
                 });*/
            });
        };
        //generamos y devolvemos un array de promesas para controlar la carga de todas las dependencias
        return Ext.Array.map(stores, storeLoader);

    },

    onSelectionChange: function (grid, selecion) {
        this.getViewModel().set('hasAnyReturned', this.hasAnyReturned(true));
        this.getViewModel().set('hasAnyPaid', this.hasAnyReturned(false));
    },


    /**
     *
     * @param selection
     * @param active
     * @returns {boolean} true si hay algún activo seleccionado y false si hay algún inactivo
     */
    hasAnyReturned: function (active) {
        var hasAny = false, selection;
        selection = this.getView().down('reemitir_reemitirdetailgrid').getSelectionModel().getSelection();
        if (selection.length) {
            hasAny = Ext.Array.contains(Ext.Array.map(selection, function (record) {
                return record.get('devuelto');
            }), active);
        }

        return hasAny;
    }
});
